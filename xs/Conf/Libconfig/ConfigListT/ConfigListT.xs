
/*
 * *********** WARNING **************
 * This file generated by Conf::Libconfig::WrapXS/0.001
 * Any changes made here will be lost
 * ***********************************
 * 1. /usr/lib/perl5/vendor_perl/5.10.0/ExtUtils/XSBuilder/WrapXS.pm:52
 * 2. /usr/lib/perl5/vendor_perl/5.10.0/ExtUtils/XSBuilder/WrapXS.pm:2068
 * 3. ./bin/WrapXSRun.pl:10
 */


#include "/media/ext4/src/src/Conf-Libconfig/src/wincompat.h"

#include "/media/ext4/src/src/Conf-Libconfig/src/scanner.h"

#include "/media/ext4/src/src/Conf-Libconfig/src/grammar.h"

#include "/media/ext4/src/src/Conf-Libconfig/src/private.h"

#include "/media/ext4/src/src/Conf-Libconfig/src/libconfig.h"

#include "EXTERN.h"

#include "perl.h"

#include "XSUB.h"

#include "libconfig_xs_sv_convert.h"

#include "libconfig_xs_typedefs.h"



void Conf__Libconfig__ConfigListT_new_init (pTHX_ Conf__Libconfig__ConfigListT  obj, SV * item, int overwrite) {

    SV * * tmpsv ;

    if (SvTYPE(item) == SVt_PVMG) 
        memcpy (obj, (void *)SvIVX(item), sizeof (*obj)) ;
    else if (SvTYPE(item) == SVt_PVHV) {
        if ((tmpsv = hv_fetch((HV *)item, "length", sizeof("length") - 1, 0)) || overwrite) {
            obj -> length = (unsigned int)config_xs_sv2_UV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
        if ((tmpsv = hv_fetch((HV *)item, "capacity", sizeof("capacity") - 1, 0)) || overwrite) {
            obj -> capacity = (unsigned int)config_xs_sv2_UV((tmpsv && *tmpsv?*tmpsv:&PL_sv_undef)) ;
        }
   ; }

    else
        croak ("initializer for Conf::Libconfig::ConfigListT::new is not a hash or object reference") ;

} ;


MODULE = Conf::Libconfig::ConfigListT    PACKAGE = Conf::Libconfig::ConfigListT 

unsigned int
length(obj, val=0)
    Conf::Libconfig::ConfigListT obj
    unsigned int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (unsigned int)  obj->length;

    if (items > 1) {
        obj->length = (unsigned int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Conf::Libconfig::ConfigListT    PACKAGE = Conf::Libconfig::ConfigListT 

unsigned int
capacity(obj, val=0)
    Conf::Libconfig::ConfigListT obj
    unsigned int val
  PREINIT:
    /*nada*/

  CODE:
    RETVAL = (unsigned int)  obj->capacity;

    if (items > 1) {
        obj->capacity = (unsigned int) val;
    }
  OUTPUT:
    RETVAL

MODULE = Conf::Libconfig::ConfigListT    PACKAGE = Conf::Libconfig::ConfigListT 



SV *
new (class,initializer=NULL)
    char * class
    SV * initializer 
PREINIT:
    SV * svobj ;
    Conf__Libconfig__ConfigListT  cobj ;
    SV * tmpsv ;
CODE:
    config_xs_Conf__Libconfig__ConfigListT_create_obj(cobj,svobj,RETVAL,malloc(sizeof(*cobj))) ;

    if (initializer) {
        if (!SvROK(initializer) || !(tmpsv = SvRV(initializer))) 
            croak ("initializer for Conf::Libconfig::ConfigListT::new is not a reference") ;

        if (SvTYPE(tmpsv) == SVt_PVHV || SvTYPE(tmpsv) == SVt_PVMG)  
            Conf__Libconfig__ConfigListT_new_init (aTHX_ cobj, tmpsv, 0) ;
        else if (SvTYPE(tmpsv) == SVt_PVAV) {
            int i ;
            SvGROW(svobj, sizeof (*cobj) * av_len((AV *)tmpsv)) ;     
            for (i = 0; i <= av_len((AV *)tmpsv); i++) {
                SV * * itemrv = av_fetch((AV *)tmpsv, i, 0) ;
                SV * item ;
                if (!itemrv || !*itemrv || !SvROK(*itemrv) || !(item = SvRV(*itemrv))) 
                    croak ("array element of initializer for Conf::Libconfig::ConfigListT::new is not a reference") ;
                Conf__Libconfig__ConfigListT_new_init (aTHX_ &cobj[i], item, 1) ;
            }
        }
        else {
             croak ("initializer for Conf::Libconfig::ConfigListT::new is not a hash/array/object reference") ;
        }
    }
OUTPUT:
    RETVAL 

PROTOTYPES: disabled

BOOT:
    items = items; /* -Wall */

